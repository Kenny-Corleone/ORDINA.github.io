import fs from 'node:fs';
import path from 'node:path';

const projectRoot = path.resolve(process.cwd());
const progressPath = path.join(projectRoot, 'progress.json');
const outputMarkdownPath = path.join(projectRoot, 'docs', 'PROGRESS.md');

function nowIso() {
  return new Date().toISOString();
}

function normalizeStatus(status) {
  const s = String(status || '').toLowerCase();
  if (s === 'done') return 'completed';
  if (s === 'inprogress') return 'in_progress';
  return s;
}

function statusIcon(status) {
  const s = normalizeStatus(status);
  if (s === 'completed') return '‚úÖ';
  if (s === 'in_progress') return 'üü°';
  if (s === 'blocked') return '‚õî';
  if (s === 'skipped') return '‚è≠Ô∏è';
  return '‚¨ú';
}

function checkbox(status) {
  return normalizeStatus(status) === 'completed' ? 'x' : ' ';
}

function percentComplete(items) {
  if (!items.length) return 0;
  const done = items.filter((i) => normalizeStatus(i.status) === 'completed').length;
  return Math.round((done / items.length) * 100);
}

function formatTerminal(progress) {
  const items = progress.items || [];
  const pct = percentComplete(items);
  const updatedAt = progress.updatedAt || '';

  const lines = [];
  lines.push(`\n${progress.title || 'Progress'}\n`);
  lines.push(`Updated: ${updatedAt}`);
  lines.push(`Progress: ${pct}% (${items.filter((i) => normalizeStatus(i.status) === 'completed').length}/${items.length})\n`);

  for (const item of items) {
    const icon = statusIcon(item.status);
    const label = item.label || item.id;
    const notes = item.notes ? ` ‚Äî ${item.notes}` : '';
    lines.push(`${icon} ${label}${notes}`);
  }

  return lines.join('\n');
}

function formatMarkdown(progress) {
  const items = progress.items || [];
  const pct = percentComplete(items);
  const updatedAt = progress.updatedAt || '';
  const done = items.filter((i) => normalizeStatus(i.status) === 'completed').length;

  const lines = [];
  lines.push('## Progress: ORDINA Svelte parity with ORDINA 1 (MAIN)');
  lines.push('');
  lines.push('This file is auto-generated by `npm run progress`.');
  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push(`**Updated:** ${updatedAt}`);
  lines.push('');
  lines.push(`**Progress:** ${pct}% (${done}/${items.length})`);
  lines.push('');
  lines.push('### Checklist');
  lines.push('');

  for (const item of items) {
    const label = item.label || item.id;
    const notes = item.notes ? ` ‚Äî ${item.notes}` : '';
    lines.push(`- [${checkbox(item.status)}] ${label}${notes}`);
  }

  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push('### Legend');
  lines.push('');
  lines.push('- ‚úÖ completed');
  lines.push('- üü° in progress');
  lines.push('- ‚¨ú pending');
  lines.push('- ‚õî blocked');
  lines.push('- ‚è≠Ô∏è skipped');
  lines.push('');

  return lines.join('\n');
}

function main() {
  if (!fs.existsSync(progressPath)) {
    console.error(`progress.json not found at: ${progressPath}`);
    process.exit(1);
  }

  const raw = fs.readFileSync(progressPath, 'utf8');
  const progress = JSON.parse(raw);
  progress.updatedAt = nowIso();

  // persist updatedAt back
  fs.writeFileSync(progressPath, JSON.stringify(progress, null, 2) + '\n', 'utf8');

  const md = formatMarkdown(progress);
  fs.mkdirSync(path.dirname(outputMarkdownPath), { recursive: true });
  fs.writeFileSync(outputMarkdownPath, md + '\n', 'utf8');

  console.log(formatTerminal(progress));
  console.log(`\nWrote: ${path.relative(projectRoot, outputMarkdownPath)}`);
}

main();

